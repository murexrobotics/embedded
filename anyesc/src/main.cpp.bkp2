#include <Arduino.h>

#define ENCODER_A 0
#define ENCODER_B 1
#define MOTOR_IN1 3
#define MOTOR_IN2 2

enum Zone {
    Bonus,
    Barrier,
    Start,
    Target,
    Empty
};

enum Move {
    Right,
    Left,
    Up,
    Down
};

const int FIELD[7][7] = {
    {Empty, Empty, Target, Barrier, Bonus, Barrier, Empty},
    {Empty, Empty, Barrier, Empty, Empty, Empty, Empty},
    {Empty, Empty, Empty, Empty, Empty, Empty, Empty},
    {Barrier, Empty, Empty, Empty, Barrier, Empty, Empty},
    {Bonus, Empty, Empty, Barrier, Empty, Empty, Bonus},
    {Empty, Empty, Barrier, Empty, Empty, Empty, Barrier},
    {Empty, Empty, Start, Empty, Empty, Empty, Empty},
};

struct Path {
    Move history[100];
    int history_len;
    int position[2]; // (y, x)
    int remaining_bonus[100][2];
    int remaining_bonus_len;
    int score; // Higher score better
};

struct Path new_path() {
    struct Path path;
    path.history_len = 0;
    path.position[0] = -1;
    path.position[1] = -1;
    path.remaining_bonus_len = 0;
    path.score = 0;

    for (int x = 0; x < 7; x++) {
        for (int y = 0; y < 7; y++) {
            if (FIELD[y][x] == Bonus) {
                path.remaining_bonus[path.remaining_bonus_len][0] = y;
                path.remaining_bonus[path.remaining_bonus_len][1] = x;
                path.remaining_bonus_len++;
            } else if (FIELD[y][x] == Start) {
                path.position[0] = y;
                path.position[1] = x;
            }
        }
    }

    return path;
}

bool move_right(struct Path *path, struct Path *new_path) {
    // At the edge of the field
    if (path->position[1] == 6) return false;

    *new_path = *path;
    // Check if there is a barrier to the right
    if (FIELD[new_path->position[0]][new_path->position[1] + 1] == Barrier) {
        return false;
    }
    // Destination is now definitely possible, update path len and position
    new_path->position[1] += 2;
    new_path->history[path->history_len] = Right;
    new_path->history_len++;

    // Check if the destination after move is special
    if (FIELD[new_path->position[0]][new_path->position[1]] == Bonus) {
        for (int i = 0; i < new_path->remaining_bonus_len; i++) {
            if (new_path->remaining_bonus[i][0] == new_path->position[0] && new_path->remaining_bonus[i][1] == new_path->position[1]) {
                new_path->score += 15;
                for (int j = i; j < new_path->remaining_bonus_len - 1; j++) {
                    new_path->remaining_bonus[j][0] = new_path->remaining_bonus[j + 1][0];
                    new_path->remaining_bonus[j][1] = new_path->remaining_bonus[j + 1][1];
                }
                new_path->remaining_bonus_len--;
                break;
            }
        }
    } else if (FIELD[new_path->position[0]][new_path->position[1]] == Target) {
        return true;
    }
    return false;
}

bool move_left(struct Path *path, struct Path *new_path) {
    // At the edge of the field
    if (path->position[1] == 0) { return false; }
    *new_path = *path;
    // Check if there is a barrier to the right
    if (FIELD[new_path->position[0]][new_path->position[1] - 1] == Barrier) {
        return false;
    }
    // Destination is now definitely possible, update path len and position
    new_path->position[1] -= 2;
    new_path->history[path->history_len] = Left;
    new_path->history_len++;

    // Check if the destination after move is special
    if (FIELD[new_path->position[0]][new_path->position[1]] == Bonus) {
        for (int i = 0; i < new_path->remaining_bonus_len; i++) {
            if (new_path->remaining_bonus[i][0] == new_path->position[0] && new_path->remaining_bonus[i][1] == new_path->position[1]) {
                new_path->score += 15;
                for (int j = i; j < new_path->remaining_bonus_len - 1; j++) {
                    new_path->remaining_bonus[j][0] = new_path->remaining_bonus[j + 1][0];
                    new_path->remaining_bonus[j][1] = new_path->remaining_bonus[j + 1][1];
                }
                new_path->remaining_bonus_len--;
                break;
            }
        }
    } else if (FIELD[new_path->position[0]][new_path->position[1]] == Target) {
        return true;
    }
    return false;
}

bool move_up(struct Path *path, struct Path *new_path) {
    // At the edge of the field
    if (path->position[1] == 6) { return false; }
    *new_path = *path;
    // Check if there is a barrier to the right
    if (FIELD[new_path->position[0] - 1][new_path->position[1]] == Barrier) {
        return false;
    }
    // Destination is now definitely possible, update path len and position
    new_path->position[1] -= 2;
    new_path->history[path->history_len] = Up;
    new_path->history_len++;

    // Check if the destination after move is special
    if (FIELD[new_path->position[0]][new_path->position[1]] == Bonus) {
        for (int i = 0; i < new_path->remaining_bonus_len; i++) {
            if (new_path->remaining_bonus[i][0] == new_path->position[0] && new_path->remaining_bonus[i][1] == new_path->position[1]) {
                new_path->score += 15;
                for (int j = i; j < new_path->remaining_bonus_len - 1; j++) {
                    new_path->remaining_bonus[j][0] = new_path->remaining_bonus[j + 1][0];
                    new_path->remaining_bonus[j][1] = new_path->remaining_bonus[j + 1][1];
                }
                new_path->remaining_bonus_len--;
                break;
            }
        }
    } else if (FIELD[new_path->position[0]][new_path->position[1]] == Target) {
        return true;
    }
    return false;
}

bool move_down(struct Path *path, struct Path *new_path) {
    // At the edge of the field
    if (path->position[1] == 6) { return false; }
    *new_path = *path;
    // Check if there is a barrier to the right
    if (FIELD[new_path->position[0] + 1][new_path->position[1]] == Barrier) {
        return false;
    }
    // Destination is now definitely possible, update path len and position
    new_path->position[1] += 2;
    new_path->history[path->history_len] = Down;
    new_path->history_len++;

    // Check if the destination after move is special
    if (FIELD[new_path->position[0]][new_path->position[1]] == Bonus) {
        for (int i = 0; i < new_path->remaining_bonus_len; i++) {
            if (new_path->remaining_bonus[i][0] == new_path->position[0] && new_path->remaining_bonus[i][1] == new_path->position[1]) {
                new_path->score += 15;
                for (int j = i; j < new_path->remaining_bonus_len - 1; j++) {
                    new_path->remaining_bonus[j][0] = new_path->remaining_bonus[j + 1][0];
                    new_path->remaining_bonus[j][1] = new_path->remaining_bonus[j + 1][1];
                }
                new_path->remaining_bonus_len--;
                break;
            }
        }
    } else if (FIELD[new_path->position[0]][new_path->position[1]] == Target) {
        return true;
    }
    return false;
}

struct Path search() {
    int pathlen = 0;
    int num_paths = 1;
    struct Path paths1[100];
    struct Path paths2[100];
    paths1[0] = new_path();

    int max_score = paths1[0].remaining_bonus_len * 15;

    int j = 0;
    for (int i = 0; i < num_paths; i++) {
        struct Path new_path;
        bool reached_target;
        for (int n = 0; n < 4; n++) {
            if (n == 0) {
                reached_target = move_right(&paths1[i], &new_path);
            } else if (n == 1) {
                reached_target = move_left(&paths1[i], &new_path);
            } else if (n == 2) {
                reached_target = move_up(&paths1[i], &new_path);
            } else if (n == 3) {
                reached_target = move_down(&paths1[i], &new_path);
            }
        }
        bool reached_target = move_right(&paths1[i], &new_path);
        if (reached_target) {
            return new_path;
        }
    }
    return paths1[0];
}







int pos = 0;
void readEncoder() {
    int b = digitalRead(ENCODER_B);
    if (b > 0) {
        pos++;
    } else {
        pos--;
    }
}

void setup() {
  Serial.begin(115200);
  delay(2000);

  Serial.println("DRV8871 test");
  
  pinMode(MOTOR_IN1, OUTPUT);
  pinMode(MOTOR_IN2, OUTPUT);
  pinMode(ENCODER_A, INPUT);
  pinMode(ENCODER_B, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENCODER_A), readEncoder, RISING);

  pinMode(25, OUTPUT);
  digitalWrite(25, HIGH);
}

void setMotor(int dir, int speed) {
    speed = constrain(speed, 0, 255);
    if (dir == 1) {
        digitalWrite(MOTOR_IN1, LOW);
        analogWrite(MOTOR_IN2, speed);
    } else {
        digitalWrite(MOTOR_IN2, LOW);
        analogWrite(MOTOR_IN1, speed);
    }
}



void loop() {
    Serial.println(pos);
    delay(100);
 
}