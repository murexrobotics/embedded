enum Zone {
    Bonus,
    Barrier,
    Start,
    Target,
    Empty
};

enum Move {
    Right,
    Left,
    Up,
    Down
};

const int FIELD[7][7] = {
    {Empty, Empty, Target, Barrier, Bonus, Barrier, Empty},
    {Empty, Empty, Barrier, Empty, Empty, Empty, Empty},
    {Empty, Empty, Empty, Empty, Empty, Empty, Empty},
    {Barrier, Empty, Empty, Empty, Barrier, Empty, Empty},
    {Bonus, Empty, Empty, Barrier, Empty, Empty, Bonus},
    {Empty, Empty, Barrier, Empty, Empty, Empty, Barrier},
    {Empty, Empty, Start, Empty, Empty, Empty, Empty},
};

struct Path {
    Move history[100];
    int history_len;
    int position[2]; // (y, x)
    int remaining_bonus[100][2];
    int remaining_bonus_len;
    int score; // Higher score better
};

struct Path new_path() {
    struct Path path;
    path.history_len = 0;
    path.position[0] = -1;
    path.position[1] = -1;
    path.remaining_bonus_len = 0;
    path.score = 0;

    for (int x = 0; x < 7; x++) {
        for (int y = 0; y < 7; y++) {
            if (FIELD[y][x] == Bonus) {
                path.remaining_bonus[path.remaining_bonus_len][0] = y;
                path.remaining_bonus[path.remaining_bonus_len][1] = x;
                path.remaining_bonus_len++;
            } else if (FIELD[y][x] == Start) {
                path.position[0] = y;
                path.position[1] = x;
            }
        }
    }

    return path;
}

bool move_right(struct Path *path, struct Path *new_path, bool *reached_target) {
    // At the edge of the field
    if (path->position[1] == 6) return false;

    *new_path = *path;
    // Check if there is a barrier to the right
    if (FIELD[new_path->position[0]][new_path->position[1] + 1] == Barrier) {
        return false;
    }
    // Destination is now definitely possible, update path len and position
    new_path->position[1] += 2;
    new_path->history[path->history_len] = Right;
    new_path->history_len++;

    // Check if the destination after move is special
    if (FIELD[new_path->position[0]][new_path->position[1]] == Bonus) {
        for (int i = 0; i < new_path->remaining_bonus_len; i++) {
            if (new_path->remaining_bonus[i][0] == new_path->position[0] && new_path->remaining_bonus[i][1] == new_path->position[1]) {
                new_path->score += 15;
                for (int j = i; j < new_path->remaining_bonus_len - 1; j++) {
                    new_path->remaining_bonus[j][0] = new_path->remaining_bonus[j + 1][0];
                    new_path->remaining_bonus[j][1] = new_path->remaining_bonus[j + 1][1];
                }
                new_path->remaining_bonus_len--;
                break;
            }
        }
    } else if (FIELD[new_path->position[0]][new_path->position[1]] == Target) {
        return true;
    }
    return false;
}

bool move_left(struct Path *path, struct Path *new_path, bool *reached_target) {
    // At the edge of the field
    if (path->position[1] == 0) { return false; }
    *new_path = *path;
    // Check if there is a barrier to the right
    if (FIELD[new_path->position[0]][new_path->position[1] - 1] == Barrier) {
        return false;
    }
    // Destination is now definitely possible, update path len and position
    new_path->position[1] -= 2;
    new_path->history[path->history_len] = Left;
    new_path->history_len++;

    // Check if the destination after move is special
    if (FIELD[new_path->position[0]][new_path->position[1]] == Bonus) {
        for (int i = 0; i < new_path->remaining_bonus_len; i++) {
            if (new_path->remaining_bonus[i][0] == new_path->position[0] && new_path->remaining_bonus[i][1] == new_path->position[1]) {
                new_path->score += 15;
                for (int j = i; j < new_path->remaining_bonus_len - 1; j++) {
                    new_path->remaining_bonus[j][0] = new_path->remaining_bonus[j + 1][0];
                    new_path->remaining_bonus[j][1] = new_path->remaining_bonus[j + 1][1];
                }
                new_path->remaining_bonus_len--;
                break;
            }
        }
    } else if (FIELD[new_path->position[0]][new_path->position[1]] == Target) {
        return true;
    }
    return false;
}

bool move_up(struct Path *path, struct Path *new_path, bool *reached_target) {
    // At the edge of the field
    if (path->position[1] == 6) { return false; }
    *new_path = *path;
    // Check if there is a barrier to the right
    if (FIELD[new_path->position[0] - 1][new_path->position[1]] == Barrier) {
        return false;
    }
    // Destination is now definitely possible, update path len and position
    new_path->position[1] -= 2;
    new_path->history[path->history_len] = Up;
    new_path->history_len++;

    // Check if the destination after move is special
    if (FIELD[new_path->position[0]][new_path->position[1]] == Bonus) {
        for (int i = 0; i < new_path->remaining_bonus_len; i++) {
            if (new_path->remaining_bonus[i][0] == new_path->position[0] && new_path->remaining_bonus[i][1] == new_path->position[1]) {
                new_path->score += 15;
                for (int j = i; j < new_path->remaining_bonus_len - 1; j++) {
                    new_path->remaining_bonus[j][0] = new_path->remaining_bonus[j + 1][0];
                    new_path->remaining_bonus[j][1] = new_path->remaining_bonus[j + 1][1];
                }
                new_path->remaining_bonus_len--;
                break;
            }
        }
    } else if (FIELD[new_path->position[0]][new_path->position[1]] == Target) {
        return true;
    }
    return false;
}

bool move_down(struct Path *path, struct Path *new_path, bool *reached_target) {
    // At the edge of the field
    if (path->position[1] == 6) { return false; }
    *new_path = *path;
    // Check if there is a barrier to the right
    if (FIELD[new_path->position[0] + 1][new_path->position[1]] == Barrier) {
        return false;
    }
    // Destination is now definitely possible, update path len and position
    new_path->position[1] += 2;
    new_path->history[path->history_len] = Down;
    new_path->history_len++;

    // Check if the destination after move is special
    if (FIELD[new_path->position[0]][new_path->position[1]] == Bonus) {
        for (int i = 0; i < new_path->remaining_bonus_len; i++) {
            if (new_path->remaining_bonus[i][0] == new_path->position[0] && new_path->remaining_bonus[i][1] == new_path->position[1]) {
                new_path->score += 15;
                for (int j = i; j < new_path->remaining_bonus_len - 1; j++) {
                    new_path->remaining_bonus[j][0] = new_path->remaining_bonus[j + 1][0];
                    new_path->remaining_bonus[j][1] = new_path->remaining_bonus[j + 1][1];
                }
                new_path->remaining_bonus_len--;
                break;
            }
        }
    } else if (FIELD[new_path->position[0]][new_path->position[1]] == Target) {
        return true;
    }
    return false;
}

void next(struct Path *path, struct Path paths[4]) {
    struct Path new_path;
    bool reached_target = false;
    if (!move_right(path, &new_path, &reached_target)) {
        paths[0] = new_path;
    }
    if (!move_left(path, &new_path, &reached_target)) {
        paths[1] = new_path;
    }
    if (!move_up(path, &new_path, &reached_target)) {
        paths[2] = new_path;
    }
    if (!move_down(path, &new_path, &reached_target)) {
        paths[3] = new_path;
    }
}

struct Path search() {
    int pathlen = 0;
    int num_paths = 1;
    struct Path paths1[100];
    struct Path paths2[100];
    struct Path new_paths[4];
    paths1[0] = new_path();

    int max_score = paths1[0].remaining_bonus_len * 15;

    for (int i = 0; i < num_paths; i++) {
        next(&paths1[i], new_paths);
        for (int j = 0; j < 4; j++) {
            if (new_paths[j] != NULL) {
                paths2[pathlen] = new_paths[j];
                pathlen++;
                if (new_paths[j].score > max_score) {
                    max_score = new_paths[j].score;
                }
            }
        }
    }

}